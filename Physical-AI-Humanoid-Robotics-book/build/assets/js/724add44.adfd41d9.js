"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[977],{6043:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"module-3-digital-twin/assets/collision-detection","title":"Collision Detection Example","description":"Overview","source":"@site/docs/module-3-digital-twin/assets/collision-detection.md","sourceDirName":"module-3-digital-twin/assets","slug":"/module-3-digital-twin/assets/collision-detection","permalink":"/docs/module-3-digital-twin/assets/collision-detection","draft":false,"unlisted":false,"editUrl":"https://github.com/physical-ai-humanoid-robotics-book/physical-ai-humanoid-robotics-book/tree/main/Physical-AI-Humanoid-Robotics-book/docs/docs/module-3-digital-twin/assets/collision-detection.md","tags":[],"version":"current","frontMatter":{}}');var o=n(4848),l=n(8453);const t={},r="Collision Detection Example",c={},a=[{value:"Overview",id:"overview",level:2},{value:"Collision Detection Principles",id:"collision-detection-principles",level:2},{value:"Collision Properties",id:"collision-properties",level:2},{value:"Contact Parameters",id:"contact-parameters",level:2},{value:"Expected Behavior",id:"expected-behavior",level:2},{value:"Validation Criteria",id:"validation-criteria",level:2},{value:"Common Collision Issues",id:"common-collision-issues",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2}];function d(e){const i={h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"collision-detection-example",children:"Collision Detection Example"})}),"\n",(0,o.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(i.p,{children:"This example demonstrates how collision detection works in the Gazebo simulation environment. Proper collision detection is essential for realistic interactions between objects and between robots and their environment."}),"\n",(0,o.jsx)(i.h2,{id:"collision-detection-principles",children:"Collision Detection Principles"}),"\n",(0,o.jsx)(i.p,{children:"Gazebo uses a combination of broad-phase and narrow-phase collision detection:"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Broad-phase"}),": Quickly identifies potentially colliding pairs"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Narrow-phase"}),": Precisely calculates collision points and forces"]}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"collision-properties",children:"Collision Properties"}),"\n",(0,o.jsx)(i.p,{children:"For effective collision detection, objects need:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Collision geometry"}),": Defines the shape used for collision detection (often simpler than visual geometry)"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Surface properties"}),": Friction, restitution (bounciness), and contact parameters"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Inertial properties"}),": Mass and moment of inertia for realistic response"]}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"contact-parameters",children:"Contact Parameters"}),"\n",(0,o.jsx)(i.p,{children:"Key parameters that affect collision behavior:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"CFM (Constraint Force Mixing)"}),": Controls constraint stiffness"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"ERP (Error Reduction Parameter)"}),": Controls how quickly position errors are corrected"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Contact surface layer"}),": Small offset to prevent objects from sinking into each other"]}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"expected-behavior",children:"Expected Behavior"}),"\n",(0,o.jsx)(i.p,{children:"When two objects collide:"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsx)(i.li,{children:"They should not pass through each other"}),"\n",(0,o.jsx)(i.li,{children:"Momentum should be conserved (approximately)"}),"\n",(0,o.jsx)(i.li,{children:"The collision response should be physically plausible"}),"\n",(0,o.jsx)(i.li,{children:"Energy should gradually dissipate (objects shouldn't bounce forever)"}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"validation-criteria",children:"Validation Criteria"}),"\n",(0,o.jsx)(i.p,{children:"To verify that collision detection is working correctly:"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsx)(i.li,{children:"Objects should stop when they hit each other or the ground"}),"\n",(0,o.jsx)(i.li,{children:"Objects should not pass through solid surfaces"}),"\n",(0,o.jsx)(i.li,{children:"Collision responses should look realistic"}),"\n",(0,o.jsx)(i.li,{children:"Robot joints should maintain their constraints during collisions"}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"common-collision-issues",children:"Common Collision Issues"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Objects passing through each other"}),": Check collision geometry and surface properties"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Objects sinking into each other"}),": Adjust ERP and contact surface layer"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Excessive bouncing"}),": Reduce restitution coefficient"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Tunneling (fast objects passing through thin obstacles)"}),": Reduce step size or use continuous collision detection"]}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Complex collision geometries can slow down simulation"}),"\n",(0,o.jsx)(i.li,{children:"Consider using simpler shapes (boxes, spheres, cylinders) for collision instead of complex meshes"}),"\n",(0,o.jsx)(i.li,{children:"Balance accuracy vs. performance based on your application needs"}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,l.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>t,x:()=>r});var s=n(6540);const o={},l=s.createContext(o);function t(e){const i=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),s.createElement(l.Provider,{value:i},e.children)}}}]);