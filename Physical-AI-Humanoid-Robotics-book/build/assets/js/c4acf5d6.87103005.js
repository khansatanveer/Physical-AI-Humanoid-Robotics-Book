"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[7303],{2427:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"module-3-digital-twin/assets/sensor-validation-methods","title":"Sensor Simulation Validation Methods","description":"Overview","source":"@site/docs/module-3-digital-twin/assets/sensor-validation-methods.md","sourceDirName":"module-3-digital-twin/assets","slug":"/module-3-digital-twin/assets/sensor-validation-methods","permalink":"/docs/module-3-digital-twin/assets/sensor-validation-methods","draft":false,"unlisted":false,"editUrl":"https://github.com/physical-ai-humanoid-robotics-book/physical-ai-humanoid-robotics-book/tree/main/Physical-AI-Humanoid-Robotics-book/docs/docs/module-3-digital-twin/assets/sensor-validation-methods.md","tags":[],"version":"current","frontMatter":{}}');var a=n(4848),l=n(8453);const t={},r="Sensor Simulation Validation Methods",o={},d=[{value:"Overview",id:"overview",level:2},{value:"LiDAR Sensor Validation",id:"lidar-sensor-validation",level:2},{value:"Physical Accuracy Validation",id:"physical-accuracy-validation",level:3},{value:"Performance Validation",id:"performance-validation",level:3},{value:"Environmental Validation",id:"environmental-validation",level:3},{value:"Depth Camera Validation",id:"depth-camera-validation",level:2},{value:"Geometric Accuracy",id:"geometric-accuracy",level:3},{value:"Performance Validation",id:"performance-validation-1",level:3},{value:"Environmental Effects",id:"environmental-effects",level:3},{value:"IMU Sensor Validation",id:"imu-sensor-validation",level:2},{value:"Static Validation",id:"static-validation",level:3},{value:"Dynamic Validation",id:"dynamic-validation",level:3},{value:"Noise and Drift Validation",id:"noise-and-drift-validation",level:3},{value:"Multi-Sensor Validation",id:"multi-sensor-validation",level:2},{value:"Cross-Sensor Consistency",id:"cross-sensor-consistency",level:3},{value:"Sensor Fusion Validation",id:"sensor-fusion-validation",level:3},{value:"Validation Tools and Scripts",id:"validation-tools-and-scripts",level:2},{value:"Automated Validation Script",id:"automated-validation-script",level:3},{value:"Validation Checklist",id:"validation-checklist",level:3},{value:"LiDAR Validation Checklist",id:"lidar-validation-checklist",level:4},{value:"Depth Camera Validation Checklist",id:"depth-camera-validation-checklist",level:4},{value:"IMU Validation Checklist",id:"imu-validation-checklist",level:4},{value:"Multi-Sensor Validation Checklist",id:"multi-sensor-validation-checklist",level:4},{value:"Acceptance Criteria",id:"acceptance-criteria",level:2},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"LiDAR Issues",id:"lidar-issues",level:3},{value:"Depth Camera Issues",id:"depth-camera-issues",level:3},{value:"IMU Issues",id:"imu-issues",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"sensor-simulation-validation-methods",children:"Sensor Simulation Validation Methods"})}),"\n",(0,a.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(i.p,{children:"This document outlines the methods and criteria for validating that the sensor simulation in the digital twin produces realistic and accurate data outputs. Proper validation ensures that the simulated sensors behave similarly to their real-world counterparts."}),"\n",(0,a.jsx)(i.h2,{id:"lidar-sensor-validation",children:"LiDAR Sensor Validation"}),"\n",(0,a.jsx)(i.h3,{id:"physical-accuracy-validation",children:"Physical Accuracy Validation"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Range Validation"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Verify that measured distances match actual distances in the environment"}),"\n",(0,a.jsx)(i.li,{children:"Test with objects at various distances (0.1m to 30m range)"}),"\n",(0,a.jsx)(i.li,{children:"Check for consistent accuracy across the entire range"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Angular Resolution Validation"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Confirm that the sensor can distinguish between closely spaced objects"}),"\n",(0,a.jsx)(i.li,{children:"Test with objects at different angles relative to the sensor"}),"\n",(0,a.jsx)(i.li,{children:"Verify that the 1-degree resolution produces expected separation"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Noise Characterization"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Measure the noise level in static conditions"}),"\n",(0,a.jsx)(i.li,{children:"Verify that noise follows expected statistical patterns"}),"\n",(0,a.jsx)(i.li,{children:"Compare noise levels to real LiDAR specifications"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"performance-validation",children:"Performance Validation"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Update Rate Consistency"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Measure actual update rate vs. configured rate (10Hz)"}),"\n",(0,a.jsx)(i.li,{children:"Check for dropped messages or timing irregularities"}),"\n",(0,a.jsx)(i.li,{children:"Validate that processing doesn't affect simulation timing"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Data Throughput"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Measure message size and transmission rate"}),"\n",(0,a.jsx)(i.li,{children:"Verify that the system can handle 360 range measurements efficiently"}),"\n",(0,a.jsx)(i.li,{children:"Test performance under various environmental complexity"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"environmental-validation",children:"Environmental Validation"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Surface Material Effects"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Test with different surface reflectivities"}),"\n",(0,a.jsx)(i.li,{children:"Verify that dark or transparent surfaces behave appropriately"}),"\n",(0,a.jsx)(i.li,{children:"Check that highly reflective surfaces don't cause artifacts"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Occlusion Handling"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Verify that objects properly block laser beams"}),"\n",(0,a.jsx)(i.li,{children:"Test multi-path effects with complex geometries"}),"\n",(0,a.jsx)(i.li,{children:"Confirm that only visible surfaces are detected"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"depth-camera-validation",children:"Depth Camera Validation"}),"\n",(0,a.jsx)(i.h3,{id:"geometric-accuracy",children:"Geometric Accuracy"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Depth Accuracy"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Compare measured depths to actual distances"}),"\n",(0,a.jsx)(i.li,{children:"Test accuracy across the full depth range (0.1m to 10m)"}),"\n",(0,a.jsx)(i.li,{children:"Verify accuracy varies predictably with distance (more error at range)"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Field of View Validation"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Confirm 60-degree horizontal FOV matches specifications"}),"\n",(0,a.jsx)(i.li,{children:"Test that objects appear at correct positions in image"}),"\n",(0,a.jsx)(i.li,{children:"Verify that the aspect ratio matches 640x480 resolution"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Resolution and Detail"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Test ability to resolve small objects at various distances"}),"\n",(0,a.jsx)(i.li,{children:"Verify that fine details are preserved appropriately"}),"\n",(0,a.jsx)(i.li,{children:"Check for aliasing or artifacts in the depth data"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"performance-validation-1",children:"Performance Validation"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Frame Rate Consistency"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Verify 30 FPS output rate is maintained"}),"\n",(0,a.jsx)(i.li,{children:"Test frame timing stability under different lighting"}),"\n",(0,a.jsx)(i.li,{children:"Check for dropped frames during complex scenes"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Memory and Processing"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Measure memory usage for depth image buffers"}),"\n",(0,a.jsx)(i.li,{children:"Validate processing time for depth calculations"}),"\n",(0,a.jsx)(i.li,{children:"Test performance with multiple depth cameras"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"environmental-effects",children:"Environmental Effects"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Lighting Conditions"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Test performance under different lighting scenarios"}),"\n",(0,a.jsx)(i.li,{children:"Verify depth accuracy in bright/dark conditions"}),"\n",(0,a.jsx)(i.li,{children:"Check for artifacts caused by strong light sources"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Transparency and Reflection"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Test behavior with transparent objects"}),"\n",(0,a.jsx)(i.li,{children:"Verify correct handling of reflective surfaces"}),"\n",(0,a.jsx)(i.li,{children:"Check for ghosting or multiple returns"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"imu-sensor-validation",children:"IMU Sensor Validation"}),"\n",(0,a.jsx)(i.h3,{id:"static-validation",children:"Static Validation"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Gravity Measurement"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Verify that static Z-axis reads ~9.8 m/s\xb2 (gravity)"}),"\n",(0,a.jsx)(i.li,{children:"Confirm X and Y axes read ~0 m/s\xb2 when level"}),"\n",(0,a.jsx)(i.li,{children:"Test with the sensor at different orientations"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Orientation Accuracy"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Compare measured orientation to known positions"}),"\n",(0,a.jsx)(i.li,{children:"Verify quaternion normalization (unit length)"}),"\n",(0,a.jsx)(i.li,{children:"Test conversion accuracy between representations"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"dynamic-validation",children:"Dynamic Validation"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Rotation Detection"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Test angular velocity measurements during rotation"}),"\n",(0,a.jsx)(i.li,{children:"Verify integration of angular velocity matches orientation"}),"\n",(0,a.jsx)(i.li,{children:"Check for drift during extended rotation tests"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Acceleration Detection"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Test linear acceleration measurements during movement"}),"\n",(0,a.jsx)(i.li,{children:"Verify that gravity compensation works correctly"}),"\n",(0,a.jsx)(i.li,{children:"Check cross-axis sensitivity and coupling"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"noise-and-drift-validation",children:"Noise and Drift Validation"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Noise Characteristics"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Measure noise levels in static conditions"}),"\n",(0,a.jsx)(i.li,{children:"Verify noise follows Gaussian distribution"}),"\n",(0,a.jsx)(i.li,{children:"Compare to specified noise parameters"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Drift Analysis"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Monitor long-term stability of measurements"}),"\n",(0,a.jsx)(i.li,{children:"Check for temperature or time-dependent drift"}),"\n",(0,a.jsx)(i.li,{children:"Verify that drift is within acceptable bounds"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"multi-sensor-validation",children:"Multi-Sensor Validation"}),"\n",(0,a.jsx)(i.h3,{id:"cross-sensor-consistency",children:"Cross-Sensor Consistency"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Temporal Synchronization"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Verify that sensors are properly timestamped"}),"\n",(0,a.jsx)(i.li,{children:"Check that data from different sensors can be correlated"}),"\n",(0,a.jsx)(i.li,{children:"Test time synchronization accuracy"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Spatial Consistency"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Confirm that sensor positions match physical model"}),"\n",(0,a.jsx)(i.li,{children:"Verify coordinate system transformations"}),"\n",(0,a.jsx)(i.li,{children:"Test consistency between different sensor measurements of same features"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"sensor-fusion-validation",children:"Sensor Fusion Validation"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Fused Output Quality"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Compare fused results to individual sensor outputs"}),"\n",(0,a.jsx)(i.li,{children:"Verify that fusion improves accuracy/reliability"}),"\n",(0,a.jsx)(i.li,{children:"Test failure modes and graceful degradation"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Performance Metrics"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Measure computational overhead of fusion"}),"\n",(0,a.jsx)(i.li,{children:"Verify real-time performance is maintained"}),"\n",(0,a.jsx)(i.li,{children:"Test resource usage under full sensor load"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"validation-tools-and-scripts",children:"Validation Tools and Scripts"}),"\n",(0,a.jsx)(i.h3,{id:"automated-validation-script",children:"Automated Validation Script"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-python",children:"#!/usr/bin/env python3\n# sensor_validation_test.py\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan, Image, Imu\nfrom std_msgs.msg import Float32MultiArray\nimport numpy as np\nimport time\nfrom collections import deque\n\nclass SensorValidator(Node):\n    def __init__(self):\n        super().__init__('sensor_validator')\n\n        # Data collection\n        self.lidar_samples = deque(maxlen=100)\n        self.imu_samples = deque(maxlen=100)\n        self.fusion_samples = deque(maxlen=100)\n\n        # Validation results\n        self.validation_results = {}\n\n        # Create subscribers\n        self.lidar_subscription = self.create_subscription(\n            LaserScan, '/basic_humanoid/scan', self.validate_lidar, 10)\n        self.imu_subscription = self.create_subscription(\n            Imu, '/basic_humanoid/imu', self.validate_imu, 10)\n        self.fusion_subscription = self.create_subscription(\n            Float32MultiArray, '/basic_humanoid/fused_sensor_state',\n            self.validate_fusion, 10)\n\n        # Timer for periodic validation\n        self.timer = self.create_timer(5.0, self.run_periodic_validation)\n\n        self.get_logger().info('Sensor Validator initialized')\n\n    def validate_lidar(self, msg):\n        \"\"\"Validate LiDAR data quality\"\"\"\n        # Check for valid ranges\n        valid_ranges = [r for r in msg.ranges if 0.1 <= r <= 30.0]\n        range_validity = len(valid_ranges) / len(msg.ranges) if msg.ranges else 0\n\n        # Check for reasonable values\n        if valid_ranges:\n            avg_range = sum(valid_ranges) / len(valid_ranges)\n            self.validation_results['lidar_avg_range'] = avg_range\n            self.validation_results['lidar_range_validity'] = range_validity\n\n        self.lidar_samples.append({\n            'timestamp': time.time(),\n            'validity_ratio': range_validity,\n            'avg_range': np.mean(valid_ranges) if valid_ranges else 0\n        })\n\n    def validate_imu(self, msg):\n        \"\"\"Validate IMU data quality\"\"\"\n        # Check quaternion normalization\n        quat_norm = np.sqrt(\n            msg.orientation.x**2 + msg.orientation.y**2 +\n            msg.orientation.z**2 + msg.orientation.w**2\n        )\n        quat_normalized = abs(quat_norm - 1.0) < 0.01\n\n        # Check gravity in Z-axis when static\n        linear_acc_magnitude = np.sqrt(\n            msg.linear_acceleration.x**2 + msg.linear_acceleration.y**2 +\n            msg.linear_acceleration.z**2\n        )\n        gravity_reasonable = abs(linear_acc_magnitude - 9.8) < 1.0  # Allow for movement\n\n        self.validation_results['imu_quat_normalized'] = quat_normalized\n        self.validation_results['imu_gravity_reasonable'] = gravity_reasonable\n\n        self.imu_samples.append({\n            'timestamp': time.time(),\n            'quat_normalized': quat_normalized,\n            'gravity_reasonable': gravity_reasonable\n        })\n\n    def validate_fusion(self, msg):\n        \"\"\"Validate fused sensor state\"\"\"\n        if len(msg.data) >= 10:  # Expected format\n            # Check position reasonableness\n            pos_magnitude = np.sqrt(msg.data[0]**2 + msg.data[1]**2 + msg.data[2]**2)\n            pos_reasonable = pos_magnitude < 100.0  # Within 100m workspace\n\n            # Check quaternion normalization\n            quat_norm = np.sqrt(msg.data[3]**2 + msg.data[4]**2 +\n                              msg.data[5]**2 + msg.data[6]**2)\n            quat_normalized = abs(quat_norm - 1.0) < 0.01\n\n            self.validation_results['fusion_pos_reasonable'] = pos_reasonable\n            self.validation_results['fusion_quat_normalized'] = quat_normalized\n\n            self.fusion_samples.append({\n                'timestamp': time.time(),\n                'pos_reasonable': pos_reasonable,\n                'quat_normalized': quat_normalized\n            })\n\n    def run_periodic_validation(self):\n        \"\"\"Run periodic validation checks\"\"\"\n        self.get_logger().info('Running periodic sensor validation...')\n\n        # LiDAR validation summary\n        if self.lidar_samples:\n            avg_validity = np.mean([s['validity_ratio'] for s in self.lidar_samples])\n            self.get_logger().info(f'LiDAR: {avg_validity*100:.1f}% valid ranges')\n\n        # IMU validation summary\n        if self.imu_samples:\n            norm_ratio = np.mean([s['quat_normalized'] for s in self.imu_samples])\n            self.get_logger().info(f'IMU: {norm_ratio*100:.1f}% normalized quaternions')\n\n        # Fusion validation summary\n        if self.fusion_samples:\n            pos_ratio = np.mean([s['pos_reasonable'] for s in self.fusion_samples])\n            quat_ratio = np.mean([s['quat_normalized'] for s in self.fusion_samples])\n            self.get_logger().info(f'Fusion: {pos_ratio*100:.1f}% reasonable positions, {quat_ratio*100:.1f}% normalized quaternions')\n\n        # Overall validation status\n        overall_pass = all([\n            avg_validity > 0.95 if self.lidar_samples else True,\n            norm_ratio > 0.99 if self.imu_samples else True,\n            pos_ratio > 0.99 if self.fusion_samples else True\n        ])\n\n        status = \"PASSED\" if overall_pass else \"FAILED\"\n        self.get_logger().info(f'Overall Validation Status: {status}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    validator = SensorValidator()\n\n    try:\n        rclpy.spin(validator)\n    except KeyboardInterrupt:\n        validator.get_logger().info('Validation stopped by user')\n    finally:\n        validator.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(i.h3,{id:"validation-checklist",children:"Validation Checklist"}),"\n",(0,a.jsx)(i.h4,{id:"lidar-validation-checklist",children:"LiDAR Validation Checklist"}),"\n",(0,a.jsxs)(i.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Range values are within 0.1m to 30m limits"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","All 360 angles are represented in scan"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Update rate is approximately 10Hz"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Noise levels are realistic"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Distant objects show expected resolution loss"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Transparent/reflective surfaces behave correctly"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Sensor mounting position matches URDF"]}),"\n"]}),"\n",(0,a.jsx)(i.h4,{id:"depth-camera-validation-checklist",children:"Depth Camera Validation Checklist"}),"\n",(0,a.jsxs)(i.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Image resolution is 640x480"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Depth values are in meters"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Horizontal FOV is approximately 60 degrees"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Update rate is approximately 30Hz"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Depth accuracy degrades predictably with distance"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Color and depth images are properly synchronized"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Sensor mounting position matches URDF"]}),"\n"]}),"\n",(0,a.jsx)(i.h4,{id:"imu-validation-checklist",children:"IMU Validation Checklist"}),"\n",(0,a.jsxs)(i.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Quaternion values are normalized (unit length)"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Static Z-axis reads ~9.8 m/s\xb2"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Update rate is approximately 100Hz"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Noise levels match configured parameters"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Orientation changes correctly with rotation"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Sensor mounting position matches URDF"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Covariance values are realistic"]}),"\n"]}),"\n",(0,a.jsx)(i.h4,{id:"multi-sensor-validation-checklist",children:"Multi-Sensor Validation Checklist"}),"\n",(0,a.jsxs)(i.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","All sensors publish simultaneously without conflict"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Coordinate systems are properly transformed"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Timestamps are synchronized across sensors"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Fused output is more accurate than individual sensors"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","System maintains real-time performance"]}),"\n",(0,a.jsxs)(i.li,{className:"task-list-item",children:[(0,a.jsx)(i.input,{type:"checkbox",disabled:!0})," ","Failure of one sensor doesn't break others"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"acceptance-criteria",children:"Acceptance Criteria"}),"\n",(0,a.jsx)(i.p,{children:"For the sensor simulation to be considered valid:"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Accuracy Requirements"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"LiDAR: Range accuracy within 1% of actual distance"}),"\n",(0,a.jsx)(i.li,{children:"Depth Camera: Depth accuracy within 5% at close range, 10% at far range"}),"\n",(0,a.jsx)(i.li,{children:"IMU: Orientation accuracy within 1 degree when static"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Performance Requirements"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"All sensors maintain configured update rates"}),"\n",(0,a.jsx)(i.li,{children:"System maintains real-time simulation (\u226530 FPS)"}),"\n",(0,a.jsxs)(i.li,{children:["Sensor processing uses ",(0,a.jsx)(i.code,{children:"<20%"})," of available CPU"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Reliability Requirements"}),":"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"99%+ of sensor messages are valid"}),"\n",(0,a.jsx)(i.li,{children:"No systematic biases in measurements"}),"\n",(0,a.jsx)(i.li,{children:"Proper handling of edge cases and invalid data"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,a.jsx)(i.h3,{id:"lidar-issues",children:"LiDAR Issues"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"No data published"}),": Check Gazebo plugin configuration and ROS remappings"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Invalid ranges"}),": Verify coordinate frames and sensor mounting"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Performance problems"}),": Reduce ray count or increase minimum range"]}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"depth-camera-issues",children:"Depth Camera Issues"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Black images"}),": Check camera parameters and lighting conditions"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"No depth data"}),": Verify depth camera plugin is loaded correctly"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Distorted images"}),": Check camera calibration parameters"]}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"imu-issues",children:"IMU Issues"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Drifting values"}),": Check noise parameters and coordinate frame alignment"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Incorrect gravity"}),": Verify sensor orientation and gravity compensation"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"High noise"}),": Adjust noise parameters in configuration"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(i.p,{children:"Proper validation of sensor simulation is critical for the digital twin's effectiveness. The methods outlined in this document provide comprehensive validation approaches for each sensor type and their integration. Regular validation should be performed to ensure continued accuracy and reliability of the sensor simulation system."})]})}function h(e={}){const{wrapper:i}={...(0,l.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>t,x:()=>r});var s=n(6540);const a={},l=s.createContext(a);function t(e){const i=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),s.createElement(l.Provider,{value:i},e.children)}}}]);