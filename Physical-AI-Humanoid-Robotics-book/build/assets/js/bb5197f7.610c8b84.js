"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[9216],{8453:(e,i,n)=>{n.d(i,{R:()=>r,x:()=>o});var t=n(6540);const s={},l=t.createContext(s);function r(e){const i=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(l.Provider,{value:i},e.children)}},9557:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-3-digital-twin/chapter-2-exercises","title":"Chapter 2: Unity Environment Building and Visualization - Exercises","description":"Exercise 2.1: Basic Unity Scene Setup","source":"@site/docs/module-3-digital-twin/chapter-2-exercises.md","sourceDirName":"module-3-digital-twin","slug":"/module-3-digital-twin/chapter-2-exercises","permalink":"/docs/module-3-digital-twin/chapter-2-exercises","draft":false,"unlisted":false,"editUrl":"https://github.com/physical-ai-humanoid-robotics-book/physical-ai-humanoid-robotics-book/tree/main/Physical-AI-Humanoid-Robotics-book/docs/docs/module-3-digital-twin/chapter-2-exercises.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2: Unity Environment Building and Visualization","permalink":"/docs/module-3-digital-twin/chapter-2-unity-visualization"},"next":{"title":"Chapter 3: Sensor Simulation and Integration","permalink":"/docs/module-3-digital-twin/chapter-3-sensor-simulation"}}');var s=n(4848),l=n(8453);const r={},o="Chapter 2: Unity Environment Building and Visualization - Exercises",a={},c=[{value:"Exercise 2.1: Basic Unity Scene Setup",id:"exercise-21-basic-unity-scene-setup",level:2},{value:"Objective",id:"objective",level:3},{value:"Tasks",id:"tasks",level:3},{value:"Implementation Steps",id:"implementation-steps",level:3},{value:"Validation Criteria",id:"validation-criteria",level:3},{value:"Submission Requirements",id:"submission-requirements",level:3},{value:"Exercise 2.2: Environment Asset Creation",id:"exercise-22-environment-asset-creation",level:2},{value:"Objective",id:"objective-1",level:3},{value:"Tasks",id:"tasks-1",level:3},{value:"Implementation Steps",id:"implementation-steps-1",level:3},{value:"Validation Criteria",id:"validation-criteria-1",level:3},{value:"Submission Requirements",id:"submission-requirements-1",level:3},{value:"Exercise 2.3: Robot Visualization Model",id:"exercise-23-robot-visualization-model",level:2},{value:"Objective",id:"objective-2",level:3},{value:"Tasks",id:"tasks-2",level:3},{value:"Implementation Steps",id:"implementation-steps-2",level:3},{value:"Validation Criteria",id:"validation-criteria-2",level:3},{value:"Submission Requirements",id:"submission-requirements-2",level:3},{value:"Exercise 2.4: Real-time Synchronization Implementation",id:"exercise-24-real-time-synchronization-implementation",level:2},{value:"Objective",id:"objective-3",level:3},{value:"Tasks",id:"tasks-3",level:3},{value:"Implementation Steps",id:"implementation-steps-3",level:3},{value:"Validation Criteria",id:"validation-criteria-3",level:3},{value:"Submission Requirements",id:"submission-requirements-3",level:3},{value:"Exercise 2.5: Interactive Elements and Controls",id:"exercise-25-interactive-elements-and-controls",level:2},{value:"Objective",id:"objective-4",level:3},{value:"Tasks",id:"tasks-4",level:3},{value:"Implementation Steps",id:"implementation-steps-4",level:3},{value:"Validation Criteria",id:"validation-criteria-4",level:3},{value:"Submission Requirements",id:"submission-requirements-4",level:3},{value:"Exercise 2.6: Performance Optimization",id:"exercise-26-performance-optimization",level:2},{value:"Objective",id:"objective-5",level:3},{value:"Tasks",id:"tasks-5",level:3},{value:"Implementation Steps",id:"implementation-steps-5",level:3},{value:"Validation Criteria",id:"validation-criteria-5",level:3},{value:"Submission Requirements",id:"submission-requirements-5",level:3},{value:"Assessment Rubric",id:"assessment-rubric",level:2},{value:"Technical Implementation (60%)",id:"technical-implementation-60",level:3},{value:"Performance (25%)",id:"performance-25",level:3},{value:"Documentation and Submission (15%)",id:"documentation-and-submission-15",level:3},{value:"Additional Challenge (Bonus 10%)",id:"additional-challenge-bonus-10",level:3}];function d(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"chapter-2-unity-environment-building-and-visualization---exercises",children:"Chapter 2: Unity Environment Building and Visualization - Exercises"})}),"\n",(0,s.jsx)(i.h2,{id:"exercise-21-basic-unity-scene-setup",children:"Exercise 2.1: Basic Unity Scene Setup"}),"\n",(0,s.jsx)(i.h3,{id:"objective",children:"Objective"}),"\n",(0,s.jsx)(i.p,{children:"Set up a basic Unity scene for digital twin visualization that matches the physics simulation from Chapter 1."}),"\n",(0,s.jsx)(i.h3,{id:"tasks",children:"Tasks"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:'Create a new Unity project named "DigitalTwinVisualization"'}),"\n",(0,s.jsx)(i.li,{children:"Configure project settings to match Gazebo physics update rates (50Hz)"}),"\n",(0,s.jsxs)(i.li,{children:["Set up a basic scene with:","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Main camera with appropriate positioning for digital twin viewing"}),"\n",(0,s.jsx)(i.li,{children:"Directional light matching Gazebo's lighting"}),"\n",(0,s.jsx)(i.li,{children:"Ground plane for reference"}),"\n",(0,s.jsx)(i.li,{children:"UI elements for displaying simulation status"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"implementation-steps",children:"Implementation Steps"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Open Unity Hub and create a new 3D (Built-in Render Pipeline) project"}),"\n",(0,s.jsx)(i.li,{children:"Configure Time settings: Maximum Allowed Timestep to 0.333, Fixed Timestep to 0.02"}),"\n",(0,s.jsx)(i.li,{children:"Create basic scene objects with appropriate transforms"}),"\n",(0,s.jsx)(i.li,{children:"Add the DigitalTwinCamera script to the main camera"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"validation-criteria",children:"Validation Criteria"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Scene runs at minimum 30 FPS"}),"\n",(0,s.jsx)(i.li,{children:"Camera follows a target object smoothly"}),"\n",(0,s.jsx)(i.li,{children:"Lighting matches the coordinate system alignment requirements"}),"\n",(0,s.jsx)(i.li,{children:"All objects are properly positioned in the scene"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"submission-requirements",children:"Submission Requirements"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Screenshot of your Unity scene hierarchy"}),"\n",(0,s.jsx)(i.li,{children:"Screenshot of the scene view showing the basic setup"}),"\n",(0,s.jsx)(i.li,{children:"Confirmation that the camera script is properly attached and functioning"}),"\n"]}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"exercise-22-environment-asset-creation",children:"Exercise 2.2: Environment Asset Creation"}),"\n",(0,s.jsx)(i.h3,{id:"objective-1",children:"Objective"}),"\n",(0,s.jsx)(i.p,{children:"Create 3D environment assets that match the Gazebo physics world from Chapter 1."}),"\n",(0,s.jsx)(i.h3,{id:"tasks-1",children:"Tasks"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["Create primitive shapes that match the obstacles in your Gazebo world:","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"A box obstacle"}),"\n",(0,s.jsx)(i.li,{children:"A cylindrical obstacle"}),"\n",(0,s.jsx)(i.li,{children:"A ramp"}),"\n",(0,s.jsx)(i.li,{children:"A platform"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.li,{children:"Apply appropriate materials to match the physics simulation"}),"\n",(0,s.jsx)(i.li,{children:"Position and scale objects to match the Gazebo world dimensions"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"implementation-steps-1",children:"Implementation Steps"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Create primitive GameObjects (Cube, Cylinder, Capsule, Cube)"}),"\n",(0,s.jsx)(i.li,{children:"Adjust position, rotation, and scale to match Gazebo world"}),"\n",(0,s.jsx)(i.li,{children:"Create and apply materials with appropriate colors and properties"}),"\n",(0,s.jsx)(i.li,{children:"Test that the visual environment matches the physics environment"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"validation-criteria-1",children:"Validation Criteria"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"All obstacles match the size and position of Gazebo world objects"}),"\n",(0,s.jsx)(i.li,{children:"Materials provide clear visual distinction between different objects"}),"\n",(0,s.jsx)(i.li,{children:"Scene hierarchy is organized and clean"}),"\n",(0,s.jsx)(i.li,{children:"Performance remains above 30 FPS with all objects present"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"submission-requirements-1",children:"Submission Requirements"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Screenshot of the Unity scene showing all environment assets"}),"\n",(0,s.jsx)(i.li,{children:"Code snippet showing how you created and positioned the objects"}),"\n",(0,s.jsx)(i.li,{children:"Description of the coordinate system conversion used"}),"\n"]}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"exercise-23-robot-visualization-model",children:"Exercise 2.3: Robot Visualization Model"}),"\n",(0,s.jsx)(i.h3,{id:"objective-2",children:"Objective"}),"\n",(0,s.jsx)(i.p,{children:"Create a Unity visualization model that matches the URDF robot from Chapter 1."}),"\n",(0,s.jsx)(i.h3,{id:"tasks-2",children:"Tasks"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Create a hierarchy of GameObjects that matches the URDF joint structure"}),"\n",(0,s.jsx)(i.li,{children:"Implement the RobotVisualization script to control joint positions"}),"\n",(0,s.jsx)(i.li,{children:"Apply appropriate materials to match the robot's appearance"}),"\n",(0,s.jsx)(i.li,{children:"Test that the visual model responds to joint position updates"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"implementation-steps-2",children:"Implementation Steps"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Create parent GameObject for the robot root"}),"\n",(0,s.jsx)(i.li,{children:"Create child GameObjects for each link (head, torso, arms, legs)"}),"\n",(0,s.jsx)(i.li,{children:"Set up the RobotVisualization component with joint information"}),"\n",(0,s.jsx)(i.li,{children:"Implement joint position updates based on input values"}),"\n",(0,s.jsx)(i.li,{children:"Test with predefined poses (standing, sitting, waving)"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"validation-criteria-2",children:"Validation Criteria"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Robot hierarchy matches the URDF structure"}),"\n",(0,s.jsx)(i.li,{children:"Joint positions update correctly when values are changed"}),"\n",(0,s.jsx)(i.li,{children:"Robot maintains realistic proportions based on URDF dimensions"}),"\n",(0,s.jsx)(i.li,{children:"Robot can be set to different poses programmatically"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"submission-requirements-2",children:"Submission Requirements"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Screenshot of the robot GameObject hierarchy"}),"\n",(0,s.jsx)(i.li,{children:"Code snippet showing the RobotVisualization implementation"}),"\n",(0,s.jsx)(i.li,{children:"Demonstration of the robot in at least two different poses"}),"\n",(0,s.jsx)(i.li,{children:"Explanation of how coordinate system conversion is handled"}),"\n"]}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"exercise-24-real-time-synchronization-implementation",children:"Exercise 2.4: Real-time Synchronization Implementation"}),"\n",(0,s.jsx)(i.h3,{id:"objective-3",children:"Objective"}),"\n",(0,s.jsx)(i.p,{children:"Implement real-time synchronization between a simulated physics system and Unity visualization."}),"\n",(0,s.jsx)(i.h3,{id:"tasks-3",children:"Tasks"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Create a mock ROS communication system to simulate joint state messages"}),"\n",(0,s.jsx)(i.li,{children:"Implement the DigitalTwinConnector script to receive joint positions"}),"\n",(0,s.jsx)(i.li,{children:"Update the robot visualization in real-time based on received data"}),"\n",(0,s.jsx)(i.li,{children:"Test synchronization performance and responsiveness"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"implementation-steps-3",children:"Implementation Steps"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Create a mock joint state publisher that generates realistic values"}),"\n",(0,s.jsx)(i.li,{children:"Implement the DigitalTwinConnector to receive and process joint data"}),"\n",(0,s.jsx)(i.li,{children:"Connect the connector to the RobotVisualization component"}),"\n",(0,s.jsx)(i.li,{children:"Add performance monitoring to track update frequency and response time"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"validation-criteria-3",children:"Validation Criteria"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Joint positions update at 50Hz (or higher) to match physics simulation"}),"\n",(0,s.jsx)(i.li,{children:"Visual updates occur with less than 100ms delay"}),"\n",(0,s.jsx)(i.li,{children:"Performance remains stable with continuous updates"}),"\n",(0,s.jsx)(i.li,{children:"Robot movements appear smooth and synchronized"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"submission-requirements-3",children:"Submission Requirements"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Code for the mock joint state publisher"}),"\n",(0,s.jsx)(i.li,{children:"Screenshot of the DigitalTwinConnector in the Unity inspector"}),"\n",(0,s.jsx)(i.li,{children:"Performance metrics showing update frequency and response time"}),"\n",(0,s.jsx)(i.li,{children:"Video or GIF showing the synchronization in action"}),"\n"]}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"exercise-25-interactive-elements-and-controls",children:"Exercise 2.5: Interactive Elements and Controls"}),"\n",(0,s.jsx)(i.h3,{id:"objective-4",children:"Objective"}),"\n",(0,s.jsx)(i.p,{children:"Add interactive elements to allow user control of the digital twin visualization."}),"\n",(0,s.jsx)(i.h3,{id:"tasks-4",children:"Tasks"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Implement camera control system for user navigation"}),"\n",(0,s.jsx)(i.li,{children:"Create UI elements for controlling robot joint positions"}),"\n",(0,s.jsx)(i.li,{children:"Add pose buttons for predefined robot positions"}),"\n",(0,s.jsx)(i.li,{children:"Implement performance monitoring display"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"implementation-steps-4",children:"Implementation Steps"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Add CameraController script to the main camera"}),"\n",(0,s.jsx)(i.li,{children:"Create UI canvas with joint sliders and pose buttons"}),"\n",(0,s.jsx)(i.li,{children:"Connect UI elements to the RobotController component"}),"\n",(0,s.jsx)(i.li,{children:"Add performance monitoring display showing FPS and frame time"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"validation-criteria-4",children:"Validation Criteria"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Camera can be controlled with mouse and keyboard"}),"\n",(0,s.jsx)(i.li,{children:"Joint sliders update robot positions in real-time"}),"\n",(0,s.jsx)(i.li,{children:"Pose buttons set the robot to predefined positions smoothly"}),"\n",(0,s.jsx)(i.li,{children:"Performance display updates correctly and shows FPS > 30"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"submission-requirements-4",children:"Submission Requirements"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Screenshot of the UI with controls visible"}),"\n",(0,s.jsx)(i.li,{children:"Code snippet showing how UI elements connect to robot control"}),"\n",(0,s.jsx)(i.li,{children:"Description of the interaction methods implemented"}),"\n",(0,s.jsx)(i.li,{children:"Performance metrics showing the impact of UI on frame rate"}),"\n"]}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"exercise-26-performance-optimization",children:"Exercise 2.6: Performance Optimization"}),"\n",(0,s.jsx)(i.h3,{id:"objective-5",children:"Objective"}),"\n",(0,s.jsxs)(i.p,{children:["Optimize the Unity scene to meet performance targets (",(0,s.jsx)(i.code,{children:"<100ms"})," response time)."]}),"\n",(0,s.jsx)(i.h3,{id:"tasks-5",children:"Tasks"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Implement Level of Detail (LOD) for complex models"}),"\n",(0,s.jsx)(i.li,{children:"Set up occlusion culling for static objects"}),"\n",(0,s.jsx)(i.li,{children:"Optimize draw calls through batching"}),"\n",(0,s.jsx)(i.li,{children:"Validate that performance targets are met"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"implementation-steps-5",children:"Implementation Steps"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Create LOD groups for complex robot models"}),"\n",(0,s.jsx)(i.li,{children:"Mark static objects for batching and lighting"}),"\n",(0,s.jsx)(i.li,{children:"Implement performance monitoring with frame time tracking"}),"\n",(0,s.jsx)(i.li,{children:"Test performance under various conditions"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"validation-criteria-5",children:"Validation Criteria"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Scene maintains >30 FPS under normal conditions"}),"\n",(0,s.jsx)(i.li,{children:"Frame time consistently stays below 100ms"}),"\n",(0,s.jsx)(i.li,{children:"LOD system switches appropriately based on distance"}),"\n",(0,s.jsx)(i.li,{children:"Draw calls are minimized through batching"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"submission-requirements-5",children:"Submission Requirements"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Performance report showing frame times before and after optimization"}),"\n",(0,s.jsx)(i.li,{children:"Screenshot of LOD settings in the Unity editor"}),"\n",(0,s.jsx)(i.li,{children:"Code for performance monitoring implementation"}),"\n",(0,s.jsx)(i.li,{children:"Description of optimization techniques applied and their impact"}),"\n"]}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"assessment-rubric",children:"Assessment Rubric"}),"\n",(0,s.jsx)(i.h3,{id:"technical-implementation-60",children:"Technical Implementation (60%)"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Correct implementation of all required components"}),"\n",(0,s.jsx)(i.li,{children:"Proper use of Unity APIs and best practices"}),"\n",(0,s.jsx)(i.li,{children:"Accurate matching between Gazebo physics and Unity visualization"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"performance-25",children:"Performance (25%)"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Achievement of performance targets (",(0,s.jsx)(i.code,{children:"<100ms"})," response time)"]}),"\n",(0,s.jsx)(i.li,{children:"Efficient use of resources and optimization techniques"}),"\n",(0,s.jsx)(i.li,{children:"Stable frame rate maintenance"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"documentation-and-submission-15",children:"Documentation and Submission (15%)"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Clear, comprehensive code documentation"}),"\n",(0,s.jsx)(i.li,{children:"Proper submission of all required artifacts"}),"\n",(0,s.jsx)(i.li,{children:"Accurate validation of implementation against criteria"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"additional-challenge-bonus-10",children:"Additional Challenge (Bonus 10%)"}),"\n",(0,s.jsx)(i.p,{children:"Extend the digital twin with additional features such as:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Real-time sensor visualization (e.g., LiDAR point clouds)"}),"\n",(0,s.jsx)(i.li,{children:"Animation blending for smoother joint movements"}),"\n",(0,s.jsx)(i.li,{children:"Network synchronization with actual ROS/Gazebo simulation"}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,l.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);