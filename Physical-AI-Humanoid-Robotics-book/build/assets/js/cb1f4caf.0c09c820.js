"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[4507],{8453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>a});var t=i(6540);const o={},r=t.createContext(o);function s(n){const e=t.useContext(r);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),t.createElement(r.Provider,{value:e},n.children)}},8570:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"isaac-sim/project/main-project","title":"Isaac Sim Main Project","description":"Project Overview","source":"@site/docs/isaac-sim/project/main-project.md","sourceDirName":"isaac-sim/project","slug":"/isaac-sim/project/main-project","permalink":"/docs/isaac-sim/project/main-project","draft":false,"unlisted":false,"editUrl":"https://github.com/physical-ai-humanoid-robotics-book/physical-ai-humanoid-robotics-book/tree/main/Physical-AI-Humanoid-Robotics-book/docs/docs/isaac-sim/project/main-project.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Isaac Sim Main Project","sidebar_position":3}}');var o=i(4848),r=i(8453);const s={title:"Isaac Sim Main Project",sidebar_position:3},a="Isaac Sim Main Project: Creating a Complete Simulation Environment",l={},c=[{value:"Project Overview",id:"project-overview",level:2},{value:"Bill of Materials (BOM)",id:"bill-of-materials-bom",level:2},{value:"Software Requirements",id:"software-requirements",level:3},{value:"Assets Required",id:"assets-required",level:3},{value:"Dependencies",id:"dependencies",level:3},{value:"Full Code Implementation",id:"full-code-implementation",level:2},{value:"Step-by-Step Instructions",id:"step-by-step-instructions",level:2},{value:"1. Setup",id:"1-setup",level:3},{value:"2. Configuration",id:"2-configuration",level:3},{value:"3. Implementation",id:"3-implementation",level:3},{value:"4. Testing",id:"4-testing",level:3},{value:"5. Validation",id:"5-validation",level:3},{value:"Visual Demonstrations",id:"visual-demonstrations",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"isaac-sim-main-project-creating-a-complete-simulation-environment",children:"Isaac Sim Main Project: Creating a Complete Simulation Environment"})}),"\n",(0,o.jsx)(e.h2,{id:"project-overview",children:"Project Overview"}),"\n",(0,o.jsx)(e.p,{children:"In this project, you'll create a complete simulation environment with multiple robots, sensors, and objects. You'll learn to:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Set up a complex scene with lighting and physics"}),"\n",(0,o.jsx)(e.li,{children:"Configure multiple robots with different sensors"}),"\n",(0,o.jsx)(e.li,{children:"Generate synthetic data for AI training"}),"\n",(0,o.jsx)(e.li,{children:"Control robots using basic control algorithms"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"bill-of-materials-bom",children:"Bill of Materials (BOM)"}),"\n",(0,o.jsx)(e.h3,{id:"software-requirements",children:"Software Requirements"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"NVIDIA Isaac Sim"}),": Latest version (requires NVIDIA GPU)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Python"}),": 3.8 or higher"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"CUDA"}),": 11.8 or higher"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Isaac Sim Python API"}),": Included with Isaac Sim installation"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"assets-required",children:"Assets Required"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Robot Models"}),": URDF/SDF files for different robot types"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Environment Models"}),": 3D models for indoor/outdoor scenes"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Sensor Configurations"}),": Camera, LIDAR, IMU configurations"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"dependencies",children:"Dependencies"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.code,{children:"omni.isaac.core"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.code,{children:"omni.isaac.sensor"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.code,{children:"numpy"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.code,{children:"opencv-python"})}),"\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.code,{children:"Pillow"})}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"full-code-implementation",children:"Full Code Implementation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nComplete Isaac Sim Project: Multi-Robot Simulation Environment\n"""\n\nimport omni\nfrom omni.isaac.core import World\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\nfrom omni.isaac.core.utils.prims import create_prim\nfrom omni.isaac.core.utils.viewports import set_camera_view\nfrom omni.isaac.core.utils.nucleus import get_assets_root_path\nfrom omni.isaac.core.utils.semantics import add_semantics\nfrom omni.isaac.sensor import Camera\nfrom omni.isaac.core.objects import DynamicCuboid\nimport numpy as np\nimport carb\nimport asyncio\nimport os\nfrom PIL import Image\nimport json\n\n\nclass MultiRobotSimulation:\n    def __init__(self):\n        self.world = None\n        self.robots = []\n        self.cameras = []\n        self.objects = []\n\n    def setup_environment(self):\n        """Set up the simulation environment with lighting and physics"""\n        print("Setting up simulation environment...")\n\n        # Initialize the world\n        self.world = World(stage_units_in_meters=1.0)\n\n        # Set up camera view\n        set_camera_view(eye=[10, 10, 10], target=[0, 0, 0])\n\n        # Add ground plane\n        create_prim(\n            prim_path="/World/GroundPlane",\n            prim_type="Plane",\n            scale=np.array([20.0, 20.0, 1.0]),\n            position=np.array([0.0, 0.0, 0.0])\n        )\n\n        # Add lighting\n        create_prim(\n            prim_path="/World/Light",\n            prim_type="DistantLight",\n            position=np.array([0, 0, 10]),\n            orientation=np.array([0.0, 0.0, 0.0, 1.0])\n        )\n\n        # Add walls to create an enclosed space\n        wall_thickness = 0.2\n        wall_height = 3.0\n        room_size = 10.0\n\n        # Front wall\n        create_prim(\n            prim_path="/World/Wall_Front",\n            prim_type="Cube",\n            scale=np.array([room_size, wall_thickness, wall_height]),\n            position=np.array([0.0, -room_size/2, wall_height/2])\n        )\n\n        # Back wall\n        create_prim(\n            prim_path="/World/Wall_Back",\n            prim_type="Cube",\n            scale=np.array([room_size, wall_thickness, wall_height]),\n            position=np.array([0.0, room_size/2, wall_height/2])\n        )\n\n        # Left wall\n        create_prim(\n            prim_path="/World/Wall_Left",\n            prim_type="Cube",\n            scale=np.array([wall_thickness, room_size, wall_height]),\n            position=np.array([-room_size/2, 0.0, wall_height/2])\n        )\n\n        # Right wall\n        create_prim(\n            prim_path="/World/Wall_Right",\n            prim_type="Cube",\n            scale=np.array([wall_thickness, room_size, wall_height]),\n            position=np.array([room_size/2, 0.0, wall_height/2])\n        )\n\n        print("Environment setup completed.")\n\n    def add_robots(self):\n        """Add multiple robots to the simulation"""\n        print("Adding robots to the simulation...")\n\n        # Add a simple cuboid robot (in a real scenario, you would load a URDF)\n        robot1 = DynamicCuboid(\n            prim_path="/World/Robot1",\n            name="robot1",\n            position=np.array([2.0, 2.0, 0.5]),\n            size=0.5,\n            mass=1.0\n        )\n        self.world.scene.add(robot1)\n\n        robot2 = DynamicCuboid(\n            prim_path="/World/Robot2",\n            name="robot2",\n            position=np.array([-2.0, -2.0, 0.5]),\n            size=0.5,\n            mass=1.0\n        )\n        self.world.scene.add(robot2)\n\n        self.robots = [robot1, robot2]\n        print(f"Added {len(self.robots)} robots to the simulation.")\n\n    def add_sensors(self):\n        """Add sensors to the robots and environment"""\n        print("Adding sensors to the environment...")\n\n        # Add a camera to observe the scene\n        camera = Camera(\n            prim_path="/World/Observer_Camera",\n            position=np.array([8.0, 8.0, 8.0]),\n            look_at_target=np.array([0, 0, 1.0])\n        )\n        camera.initialize()\n        camera.add_raw_image_to_frame()\n        camera.add_depth_image_to_frame()\n\n        self.cameras.append(camera)\n        self.world.scene.add_sensor("observer_camera", camera)\n\n        print(f"Added {len(self.cameras)} cameras to the simulation.")\n\n    def add_objects(self):\n        """Add objects for the robots to interact with"""\n        print("Adding objects to the environment...")\n\n        # Add some objects for the robots to navigate around\n        colors = [\n            [1.0, 0.0, 0.0, 1.0],  # Red\n            [0.0, 1.0, 0.0, 1.0],  # Green\n            [0.0, 0.0, 1.0, 1.0],  # Blue\n            [1.0, 1.0, 0.0, 1.0],  # Yellow\n        ]\n\n        positions = [\n            np.array([3.0, 0.0, 0.2]),\n            np.array([-3.0, 0.0, 0.2]),\n            np.array([0.0, 3.0, 0.2]),\n            np.array([0.0, -3.0, 0.2]),\n        ]\n\n        for i, (color, pos) in enumerate(zip(colors, positions)):\n            obj = DynamicCuboid(\n                prim_path=f"/World/Object_{i}",\n                name=f"object_{i}",\n                position=pos,\n                size=0.3,\n                mass=0.5,\n                color=np.array(color)\n            )\n            self.world.scene.add(obj)\n            self.objects.append(obj)\n\n        print(f"Added {len(self.objects)} objects to the simulation.")\n\n    def run_simulation(self, num_steps=1000):\n        """Run the simulation for a specified number of steps"""\n        print(f"Starting simulation for {num_steps} steps...")\n\n        # Reset the world to apply all changes\n        self.world.reset()\n\n        # Create output directory for data\n        output_dir = "./project_output"\n        os.makedirs(output_dir, exist_ok=True)\n\n        for step in range(num_steps):\n            # Step the world\n            self.world.step(render=True)\n\n            # Occasionally save camera data\n            if step % 100 == 0:\n                print(f"Simulation step: {step}/{num_steps}")\n\n                # Capture camera data if available\n                if self.cameras:\n                    camera = self.cameras[0]\n                    try:\n                        rgb_data = camera.get_raw_image()\n                        if rgb_data is not None:\n                            rgb_image = Image.fromarray(rgb_data, mode="RGBA")\n                            rgb_image.save(f"{output_dir}/scene_{step:04d}.png")\n                    except Exception as e:\n                        print(f"Error capturing camera data: {e}")\n\n            # Simple robot control - move robots in a circle\n            if step > 50:  # Wait for initial settling\n                time_factor = step / 100.0\n                for i, robot in enumerate(self.robots):\n                    try:\n                        # Calculate circular motion\n                        angle = time_factor + (i * np.pi)  # Offset for each robot\n                        target_x = 3 * np.cos(angle)\n                        target_y = 3 * np.sin(angle)\n\n                        # Apply simple control to move robot\n                        # In a real implementation, you would use proper control algorithms\n                        pass\n                    except Exception as e:\n                        print(f"Error controlling robot {i}: {e}")\n\n        print("Simulation completed.")\n\n    def run_project(self):\n        """Run the complete project"""\n        try:\n            self.setup_environment()\n            self.add_robots()\n            self.add_sensors()\n            self.add_objects()\n            self.run_simulation()\n\n            print("Project completed successfully!")\n\n        except Exception as e:\n            print(f"Error during project execution: {e}")\n            raise\n        finally:\n            if self.world:\n                self.world.clear()\n\n\ndef main():\n    """Main function to run the project"""\n    print("Starting Isaac Sim Multi-Robot Simulation Project...")\n\n    sim_project = MultiRobotSimulation()\n    sim_project.run_project()\n\n    print("Project finished!")\n\n\nif __name__ == "__main__":\n    main()\n\n    # Shutdown Isaac Sim\n    print("Shutting down Isaac Sim...")\n    omni.kit.app.get_app().close()\n'})}),"\n",(0,o.jsx)(e.h2,{id:"step-by-step-instructions",children:"Step-by-Step Instructions"}),"\n",(0,o.jsx)(e.h3,{id:"1-setup",children:"1. Setup"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Ensure Isaac Sim is properly installed with all dependencies"}),"\n",(0,o.jsx)(e.li,{children:"Create a new Python environment with required packages"}),"\n",(0,o.jsx)(e.li,{children:"Verify your system meets the hardware requirements (NVIDIA GPU with RTX support)"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"2-configuration",children:"2. Configuration"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Set up the project directory structure as shown in the code"}),"\n",(0,o.jsx)(e.li,{children:"Configure your Python environment with Isaac Sim paths"}),"\n",(0,o.jsx)(e.li,{children:"Verify camera and sensor settings are properly configured"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"3-implementation",children:"3. Implementation"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Run the setup_environment() function to create the scene"}),"\n",(0,o.jsx)(e.li,{children:"Add robots using the add_robots() function"}),"\n",(0,o.jsx)(e.li,{children:"Install sensors with the add_sensors() function"}),"\n",(0,o.jsx)(e.li,{children:"Place objects using the add_objects() function"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"4-testing",children:"4. Testing"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Execute the simulation with run_simulation()"}),"\n",(0,o.jsx)(e.li,{children:"Monitor the console output for any errors"}),"\n",(0,o.jsx)(e.li,{children:"Verify that robots move according to the control algorithm"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"5-validation",children:"5. Validation"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Check that synthetic data is being generated correctly"}),"\n",(0,o.jsx)(e.li,{children:"Verify that all sensors are providing expected outputs"}),"\n",(0,o.jsx)(e.li,{children:"Confirm that the physics simulation is behaving as expected"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"visual-demonstrations",children:"Visual Demonstrations"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"[GIF/Video 1]: Complete simulation environment with multiple robots"}),"\n",(0,o.jsx)(e.li,{children:"[GIF/Video 2]: Camera data capture and synthetic data generation"}),"\n",(0,o.jsx)(e.li,{children:"[GIF/Video 3]: Robot movement and navigation in the environment"}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}}}]);