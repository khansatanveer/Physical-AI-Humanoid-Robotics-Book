"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[288],{5140:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>m});const r=JSON.parse('{"id":"module-3-digital-twin/assets/unity-performance-validation","title":"Unity Performance Validation for Digital Twin Visualization","description":"Performance Targets","source":"@site/docs/module-3-digital-twin/assets/unity-performance-validation.md","sourceDirName":"module-3-digital-twin/assets","slug":"/module-3-digital-twin/assets/unity-performance-validation","permalink":"/docs/module-3-digital-twin/assets/unity-performance-validation","draft":false,"unlisted":false,"editUrl":"https://github.com/physical-ai-humanoid-robotics-book/physical-ai-humanoid-robotics-book/tree/main/Physical-AI-Humanoid-Robotics-book/docs/docs/module-3-digital-twin/assets/unity-performance-validation.md","tags":[],"version":"current","frontMatter":{}}');var t=i(4848),a=i(8453);const s={},o="Unity Performance Validation for Digital Twin Visualization",l={},m=[{value:"Performance Targets",id:"performance-targets",level:2},{value:"Validation Methodology",id:"validation-methodology",level:2},{value:"Frame Time Measurement",id:"frame-time-measurement",level:3},{value:"Tools for Performance Measurement",id:"tools-for-performance-measurement",level:3},{value:"Unity Profiler",id:"unity-profiler",level:4},{value:"Custom Performance Monitor",id:"custom-performance-monitor",level:4},{value:"Frame Timing Analysis",id:"frame-timing-analysis",level:4},{value:"Performance Optimization Guidelines",id:"performance-optimization-guidelines",level:3},{value:"For Rendering Performance (&lt; 100ms target)",id:"for-rendering-performance--100ms-target",level:4},{value:"Common Performance Issues and Solutions",id:"common-performance-issues-and-solutions",level:4},{value:"Validation Checklist",id:"validation-checklist",level:3},{value:"Performance Testing Script",id:"performance-testing-script",level:3},{value:"Performance Optimization Results",id:"performance-optimization-results",level:3},{value:"Validation Summary",id:"validation-summary",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"unity-performance-validation-for-digital-twin-visualization",children:"Unity Performance Validation for Digital Twin Visualization"})}),"\n",(0,t.jsx)(n.h2,{id:"performance-targets",children:"Performance Targets"}),"\n",(0,t.jsx)(n.p,{children:"As specified in the requirements, the Unity visualization must meet these performance targets:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Unity rendering: < 100ms response time"}),"\n",(0,t.jsx)(n.li,{children:"Sustained frame rate: > 30 FPS for smooth visualization"}),"\n",(0,t.jsx)(n.li,{children:"Synchronization delay: < 50ms between physics updates and visualization"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"validation-methodology",children:"Validation Methodology"}),"\n",(0,t.jsx)(n.h3,{id:"frame-time-measurement",children:"Frame Time Measurement"}),"\n",(0,t.jsx)(n.p,{children:"To validate that Unity rendering meets the < 100ms requirement:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Monitor frame time using Unity's Time.deltaTime"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Track Time.unscaledDeltaTime for each frame"}),"\n",(0,t.jsx)(n.li,{children:"Calculate average, minimum, and maximum frame times"}),"\n",(0,t.jsx)(n.li,{children:"Ensure 95th percentile frame time is < 100ms"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use PerformanceMonitor script"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Performance monitoring script\nusing UnityEngine;\n\npublic class PerformanceMonitor : MonoBehaviour\n{\n    private float[] frameTimes = new float[60];\n    private int frameIndex = 0;\n    private float[] frameTimeHistory = new float[1000]; // For statistical analysis\n    private int historyIndex = 0;\n\n    void Update()\n    {\n        // Record current frame time\n        float currentFrameTime = Time.unscaledDeltaTime;\n        frameTimes[frameIndex] = currentFrameTime;\n        frameIndex = (frameIndex + 1) % frameTimes.Length;\n\n        // Store in history for analysis\n        frameTimeHistory[historyIndex] = currentFrameTime;\n        historyIndex = (historyIndex + 1) % frameTimeHistory.Length;\n\n        // Check if we\'re meeting the <100ms response requirement\n        if (currentFrameTime > 0.1f) // 100ms threshold\n        {\n            Debug.LogWarning($"Frame time exceeded 100ms: {currentFrameTime * 1000:F1}ms");\n        }\n    }\n\n    public float GetAverageFrameTime()\n    {\n        float sum = 0;\n        for (int i = 0; i < frameTimes.Length; i++)\n        {\n            sum += frameTimes[i];\n        }\n        return sum / frameTimes.Length;\n    }\n\n    public float GetMaxFrameTime()\n    {\n        float max = 0;\n        for (int i = 0; i < frameTimes.Length; i++)\n        {\n            if (frameTimes[i] > max)\n                max = frameTimes[i];\n        }\n        return max;\n    }\n\n    public float GetPercentileFrameTime(float percentile)\n    {\n        // Create a copy of the history and sort it\n        float[] sortedHistory = new float[frameTimeHistory.Length];\n        System.Array.Copy(frameTimeHistory, sortedHistory, frameTimeHistory.Length);\n        System.Array.Sort(sortedHistory);\n\n        // Calculate the index for the requested percentile\n        int index = (int)(percentile * sortedHistory.Length);\n        return sortedHistory[Mathf.Clamp(index, 0, sortedHistory.Length - 1)];\n    }\n\n    public int GetFps()\n    {\n        float avgFrameTime = GetAverageFrameTime();\n        if (avgFrameTime > 0)\n        {\n            return Mathf.RoundToInt(1.0f / avgFrameTime);\n        }\n        return 0;\n    }\n\n    public bool IsMeetingPerformanceTarget()\n    {\n        // Check if 95th percentile frame time is under 100ms\n        float p95FrameTime = GetPercentileFrameTime(0.95f);\n        return p95FrameTime < 0.1f; // 100ms\n    }\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"tools-for-performance-measurement",children:"Tools for Performance Measurement"}),"\n",(0,t.jsx)(n.h4,{id:"unity-profiler",children:"Unity Profiler"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"CPU usage analysis"}),"\n",(0,t.jsx)(n.li,{children:"Rendering statistics"}),"\n",(0,t.jsx)(n.li,{children:"Memory usage tracking"}),"\n",(0,t.jsx)(n.li,{children:"Frame debugging capabilities"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"custom-performance-monitor",children:"Custom Performance Monitor"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Real-time frame time tracking"}),"\n",(0,t.jsx)(n.li,{children:"Statistical analysis of performance metrics"}),"\n",(0,t.jsx)(n.li,{children:"Alert system for performance issues"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"frame-timing-analysis",children:"Frame Timing Analysis"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Average frame time calculation"}),"\n",(0,t.jsx)(n.li,{children:"Peak frame time detection"}),"\n",(0,t.jsx)(n.li,{children:"Consistency analysis"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"performance-optimization-guidelines",children:"Performance Optimization Guidelines"}),"\n",(0,t.jsx)(n.h4,{id:"for-rendering-performance--100ms-target",children:"For Rendering Performance (< 100ms target)"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Reduce Draw Calls"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use static batching for non-moving objects"}),"\n",(0,t.jsx)(n.li,{children:"Use dynamic batching for small moving objects"}),"\n",(0,t.jsx)(n.li,{children:"Combine materials where possible"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Optimize Rendering Pipeline"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use Level of Detail (LOD) systems"}),"\n",(0,t.jsx)(n.li,{children:"Implement occlusion culling"}),"\n",(0,t.jsx)(n.li,{children:"Optimize shader complexity"}),"\n",(0,t.jsx)(n.li,{children:"Reduce overdraw"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Optimize GameObjects"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Minimize complex hierarchies"}),"\n",(0,t.jsx)(n.li,{children:"Use object pooling for frequently created/destroyed objects"}),"\n",(0,t.jsx)(n.li,{children:"Optimize update loops and coroutines"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"common-performance-issues-and-solutions",children:"Common Performance Issues and Solutions"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"High frame times"}),": Reduce polygon count, optimize shaders, use LOD"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Inconsistent frame times"}),": Minimize garbage collection, optimize update loops"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"High memory usage"}),": Use object pooling, optimize asset loading"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Synchronization delays"}),": Optimize ROS communication frequency"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"validation-checklist",children:"Validation Checklist"}),"\n",(0,t.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Average frame time consistently below 33ms (for 30 FPS)"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","95th percentile frame time below 100ms"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Sustained performance during robot movement and interaction"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","No dropped frames during critical visualization updates"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Performance monitoring displays accurate metrics"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Robot joint updates occur with < 50ms delay from physics simulation"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"performance-testing-script",children:"Performance Testing Script"}),"\n",(0,t.jsx)(n.p,{children:"A complete performance validation would include a test script that:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Runs the visualization for a fixed duration (e.g., 60 seconds)"}),"\n",(0,t.jsx)(n.li,{children:"Records frame times at regular intervals"}),"\n",(0,t.jsx)(n.li,{children:"Calculates average, peak, and percentile frame times"}),"\n",(0,t.jsx)(n.li,{children:"Verifies all metrics meet requirements"}),"\n",(0,t.jsx)(n.li,{children:"Generates a performance report"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Example performance validation test\nusing UnityEngine;\nusing System.Collections;\n\npublic class PerformanceValidationTest : MonoBehaviour\n{\n    public PerformanceMonitor performanceMonitor;\n    public float testDuration = 60.0f; // 60 seconds\n    public float updateInterval = 5.0f; // Report every 5 seconds\n\n    private float testStartTime;\n    private bool isTestRunning = false;\n\n    public void StartValidationTest()\n    {\n        if (performanceMonitor == null)\n        {\n            performanceMonitor = FindObjectOfType<PerformanceMonitor>();\n        }\n\n        testStartTime = Time.time;\n        isTestRunning = true;\n        StartCoroutine(RunValidationTest());\n    }\n\n    IEnumerator RunValidationTest()\n    {\n        float nextReportTime = Time.time + updateInterval;\n\n        while (Time.time - testStartTime < testDuration && isTestRunning)\n        {\n            if (Time.time >= nextReportTime)\n            {\n                GeneratePerformanceReport();\n                nextReportTime += updateInterval;\n            }\n\n            yield return null;\n        }\n\n        // Final report\n        GenerateFinalPerformanceReport();\n        isTestRunning = false;\n    }\n\n    void GeneratePerformanceReport()\n    {\n        float avgFrameTime = performanceMonitor.GetAverageFrameTime();\n        float p95FrameTime = performanceMonitor.GetPercentileFrameTime(0.95f);\n        int fps = performanceMonitor.GetFps();\n\n        Debug.Log($"Performance Report (Time: {Time.time - testStartTime:F1}s):\\n" +\n                  $"Average Frame Time: {avgFrameTime * 1000:F1}ms\\n" +\n                  $"95th Percentile Frame Time: {p95FrameTime * 1000:F1}ms\\n" +\n                  $"Current FPS: {fps}\\n" +\n                  $"Target < 100ms: {(p95FrameTime < 0.1f ? "PASS" : "FAIL")}");\n    }\n\n    void GenerateFinalPerformanceReport()\n    {\n        float avgFrameTime = performanceMonitor.GetAverageFrameTime();\n        float maxFrameTime = performanceMonitor.GetMaxFrameTime();\n        float p95FrameTime = performanceMonitor.GetPercentileFrameTime(0.95f);\n        int fps = performanceMonitor.GetFps();\n\n        string result = $"Final Performance Validation Results:\\n" +\n                       $"Test Duration: {testDuration}s\\n" +\n                       $"Average Frame Time: {avgFrameTime * 1000:F1}ms\\n" +\n                       $"Max Frame Time: {maxFrameTime * 1000:F1}ms\\n" +\n                       $"95th Percentile Frame Time: {p95FrameTime * 1000:F1}ms\\n" +\n                       $"Average FPS: {fps}\\n" +\n                       $"Performance Target Met: {(p95FrameTime < 0.1f ? "YES" : "NO")}\\n";\n\n        Debug.Log(result);\n\n        if (p95FrameTime < 0.1f)\n        {\n            Debug.Log("\u2705 Unity rendering performance validation PASSED");\n        }\n        else\n        {\n            Debug.LogError("\u274c Unity rendering performance validation FAILED - Frame times exceed 100ms target");\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"performance-optimization-results",children:"Performance Optimization Results"}),"\n",(0,t.jsx)(n.p,{children:"Based on the implementation of the digital twin visualization:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Scene Optimization"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Static batching enabled for environment objects"}),"\n",(0,t.jsx)(n.li,{children:"LOD system implemented for robot model"}),"\n",(0,t.jsx)(n.li,{children:"Occlusion culling configured for large scenes"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Script Optimization"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Update frequency limited to physics simulation rate (50Hz)"}),"\n",(0,t.jsx)(n.li,{children:"Efficient joint update algorithms"}),"\n",(0,t.jsx)(n.li,{children:"Object pooling for dynamic elements"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Rendering Optimization"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Standard shader with minimal complexity"}),"\n",(0,t.jsx)(n.li,{children:"Appropriate level of detail for real-time performance"}),"\n",(0,t.jsx)(n.li,{children:"Efficient lighting setup with shadows balanced for performance"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"validation-summary",children:"Validation Summary"}),"\n",(0,t.jsx)(n.p,{children:"The Unity visualization system has been designed and implemented with performance as a primary consideration. The system includes:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Real-time performance monitoring with frame time tracking"}),"\n",(0,t.jsx)(n.li,{children:"Optimization techniques to maintain < 100ms response time"}),"\n",(0,t.jsx)(n.li,{children:"Statistical analysis of performance metrics"}),"\n",(0,t.jsx)(n.li,{children:"Automated validation testing capabilities"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This validation ensures the Unity visualization provides real-time performance suitable for digital twin applications, maintaining synchronization with the physics simulation while providing smooth, responsive visualization."})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var r=i(6540);const t={},a=r.createContext(t);function s(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);